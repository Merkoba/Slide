(function(){"use strict";class Ct extends AudioWorkletProcessor{constructor(t){super(t),this.started=!1,this.nbInputs=t.numberOfInputs,this.nbOutputs=t.numberOfOutputs,this.blockSize=t.processorOptions.blockSize,this.hopSize=128,this.nbOverlaps=this.blockSize/this.hopSize,this.inputBuffers=new Array(this.nbInputs),this.inputBuffersHead=new Array(this.nbInputs),this.inputBuffersToSend=new Array(this.nbInputs);for(let e=0;e<this.nbInputs;e++)this.allocateInputChannels(e,1);this.outputBuffers=new Array(this.nbOutputs),this.outputBuffersToRetrieve=new Array(this.nbOutputs);for(let e=0;e<this.nbOutputs;e++)this.allocateOutputChannels(e,1)}reallocateChannelsIfNeeded(t,e){for(let s=0;s<this.nbInputs;s++){let r=t[s].length;r!=this.inputBuffers[s].length&&this.allocateInputChannels(s,r)}for(let s=0;s<this.nbOutputs;s++){let r=e[s].length;r!=this.outputBuffers[s].length&&this.allocateOutputChannels(s,r)}}allocateInputChannels(t,e){this.inputBuffers[t]=new Array(e);for(let s=0;s<e;s++)this.inputBuffers[t][s]=new Float32Array(this.blockSize+128),this.inputBuffers[t][s].fill(0);this.inputBuffersHead[t]=new Array(e),this.inputBuffersToSend[t]=new Array(e);for(let s=0;s<e;s++)this.inputBuffersHead[t][s]=this.inputBuffers[t][s].subarray(0,this.blockSize),this.inputBuffersToSend[t][s]=new Float32Array(this.blockSize)}allocateOutputChannels(t,e){this.outputBuffers[t]=new Array(e);for(let s=0;s<e;s++)this.outputBuffers[t][s]=new Float32Array(this.blockSize),this.outputBuffers[t][s].fill(0);this.outputBuffersToRetrieve[t]=new Array(e);for(let s=0;s<e;s++)this.outputBuffersToRetrieve[t][s]=new Float32Array(this.blockSize),this.outputBuffersToRetrieve[t][s].fill(0)}readInputs(t){if(t[0].length&&t[0][0].length==0){for(let e=0;e<this.nbInputs;e++)for(let s=0;s<this.inputBuffers[e].length;s++)this.inputBuffers[e][s].fill(0,this.blockSize);return}for(let e=0;e<this.nbInputs;e++)for(let s=0;s<this.inputBuffers[e].length;s++){let r=t[e][s];this.inputBuffers[e][s].set(r,this.blockSize)}}writeOutputs(t){for(let e=0;e<this.nbInputs;e++)for(let s=0;s<this.inputBuffers[e].length;s++){let r=this.outputBuffers[e][s].subarray(0,128);t[e][s].set(r)}}shiftInputBuffers(){for(let t=0;t<this.nbInputs;t++)for(let e=0;e<this.inputBuffers[t].length;e++)this.inputBuffers[t][e].copyWithin(0,128)}shiftOutputBuffers(){for(let t=0;t<this.nbOutputs;t++)for(let e=0;e<this.outputBuffers[t].length;e++)this.outputBuffers[t][e].copyWithin(0,128),this.outputBuffers[t][e].subarray(this.blockSize-128).fill(0)}prepareInputBuffersToSend(){for(let t=0;t<this.nbInputs;t++)for(let e=0;e<this.inputBuffers[t].length;e++)this.inputBuffersToSend[t][e].set(this.inputBuffersHead[t][e])}handleOutputBuffersToRetrieve(){for(let t=0;t<this.nbOutputs;t++)for(let e=0;e<this.outputBuffers[t].length;e++)for(let s=0;s<this.blockSize;s++)this.outputBuffers[t][e][s]+=this.outputBuffersToRetrieve[t][e][s]/this.nbOverlaps}process(t,e,s){const i=t[0][0]!==void 0;return this.started&&!i?!1:(this.started=i,this.reallocateChannelsIfNeeded(t,e),this.readInputs(t),this.shiftInputBuffers(),this.prepareInputBuffersToSend(),this.processOLA(this.inputBuffersToSend,this.outputBuffersToRetrieve,s),this.handleOutputBuffersToRetrieve(),this.writeOutputs(e),this.shiftOutputBuffers(),!0)}processOLA(t,e,s){console.assert(!1,"Not overriden")}}class Rt{constructor(t){if(this.size=t|0,this.size<=1||(this.size&this.size-1)!==0)throw new Error("FFT size must be a power of two and bigger than 1");this._csize=t<<1;for(var e=new Array(this.size*2),s=0;s<e.length;s+=2){const c=Math.PI*s/this.size;e[s]=Math.cos(c),e[s+1]=-Math.sin(c)}this.table=e;for(var r=0,i=1;this.size>i;i<<=1)r++;this._width=r%2===0?r-1:r,this._bitrev=new Array(1<<this._width);for(var o=0;o<this._bitrev.length;o++){this._bitrev[o]=0;for(var a=0;a<this._width;a+=2){var u=this._width-a-2;this._bitrev[o]|=(o>>>a&3)<<u}}this._out=null,this._data=null,this._inv=0}fromComplexArray(t,e){for(var s=e||new Array(t.length>>>1),r=0;r<t.length;r+=2)s[r>>>1]=t[r];return s}createComplexArray(){const t=new Array(this._csize);for(var e=0;e<t.length;e++)t[e]=0;return t}toComplexArray(t,e){for(var s=e||this.createComplexArray(),r=0;r<s.length;r+=2)s[r]=t[r>>>1],s[r+1]=0;return s}completeSpectrum(t){for(var e=this._csize,s=e>>>1,r=2;r<s;r+=2)t[e-r]=t[r],t[e-r+1]=-t[r+1]}transform(t,e){if(t===e)throw new Error("Input and output buffers must be different");this._out=t,this._data=e,this._inv=0,this._transform4(),this._out=null,this._data=null}realTransform(t,e){if(t===e)throw new Error("Input and output buffers must be different");this._out=t,this._data=e,this._inv=0,this._realTransform4(),this._out=null,this._data=null}inverseTransform(t,e){if(t===e)throw new Error("Input and output buffers must be different");this._out=t,this._data=e,this._inv=1,this._transform4();for(var s=0;s<t.length;s++)t[s]/=this.size;this._out=null,this._data=null}_transform4(){var t=this._out,e=this._csize,s=this._width,r=1<<s,i=e/r<<1,o,a,u=this._bitrev;if(i===4)for(o=0,a=0;o<e;o+=i,a++){const m=u[a];this._singleTransform2(o,m,r)}else for(o=0,a=0;o<e;o+=i,a++){const m=u[a];this._singleTransform4(o,m,r)}var c=this._inv?-1:1,h=this.table;for(r>>=2;r>=2;r>>=2){i=e/r<<1;var f=i>>>2;for(o=0;o<e;o+=i)for(var d=o+f,l=o,p=0;l<d;l+=2,p+=r){const m=l,I=m+f,g=I+f,v=g+f,B=t[m],T=t[m+1],M=t[I],S=t[I+1],P=t[g],V=t[g+1],x=t[v],y=t[v+1],z=B,A=T,k=h[p],N=c*h[p+1],O=M*k-S*N,E=M*N+S*k,q=h[2*p],F=c*h[2*p+1],tt=P*q-V*F,et=P*F+V*q,st=h[3*p],rt=c*h[3*p+1],nt=x*st-y*rt,it=x*rt+y*st,ot=z+tt,Z=A+et,$=z-tt,at=A-et,ct=O+nt,G=E+it,Q=c*(O-nt),ut=c*(E-it),ht=ot+ct,vt=Z+G,gt=ot-ct,bt=Z-G,It=$+ut,_t=at-Q,Bt=$-ut,wt=at+Q;t[m]=ht,t[m+1]=vt,t[I]=It,t[I+1]=_t,t[g]=gt,t[g+1]=bt,t[v]=Bt,t[v+1]=wt}}}_singleTransform2(t,e,s){const r=this._out,i=this._data,o=i[e],a=i[e+1],u=i[e+s],c=i[e+s+1],h=o+u,f=a+c,d=o-u,l=a-c;r[t]=h,r[t+1]=f,r[t+2]=d,r[t+3]=l}_singleTransform4(t,e,s){const r=this._out,i=this._data,o=this._inv?-1:1,a=s*2,u=s*3,c=i[e],h=i[e+1],f=i[e+s],d=i[e+s+1],l=i[e+a],p=i[e+a+1],m=i[e+u],I=i[e+u+1],g=c+l,v=h+p,B=c-l,T=h-p,M=f+m,S=d+I,P=o*(f-m),V=o*(d-I),x=g+M,y=v+S,z=B+V,A=T-P,k=g-M,N=v-S,O=B-V,E=T+P;r[t]=x,r[t+1]=y,r[t+2]=z,r[t+3]=A,r[t+4]=k,r[t+5]=N,r[t+6]=O,r[t+7]=E}_realTransform4(){var t=this._out,e=this._csize,s=this._width,r=1<<s,i=e/r<<1,o,a,u=this._bitrev;if(i===4)for(o=0,a=0;o<e;o+=i,a++){const Tt=u[a];this._singleRealTransform2(o,Tt>>>1,r>>>1)}else for(o=0,a=0;o<e;o+=i,a++){const Tt=u[a];this._singleRealTransform4(o,Tt>>>1,r>>>1)}var c=this._inv?-1:1,h=this.table;for(r>>=2;r>=2;r>>=2){i=e/r<<1;var f=i>>>1,d=f>>>1,l=d>>>1;for(o=0;o<e;o+=i)for(var p=0,m=0;p<=l;p+=2,m+=r){var I=o+p,g=I+d,v=g+d,B=v+d,T=t[I],M=t[I+1],S=t[g],P=t[g+1],V=t[v],x=t[v+1],y=t[B],z=t[B+1],A=T,k=M,N=h[m],O=c*h[m+1],E=S*N-P*O,q=S*O+P*N,F=h[2*m],tt=c*h[2*m+1],et=V*F-x*tt,st=V*tt+x*F,rt=h[3*m],nt=c*h[3*m+1],it=y*rt-z*nt,ot=y*nt+z*rt,Z=A+et,$=k+st,at=A-et,ct=k-st,G=E+it,Q=q+ot,ut=c*(E-it),ht=c*(q-ot),vt=Z+G,gt=$+Q,bt=at+ht,It=ct-ut;if(t[I]=vt,t[I+1]=gt,t[g]=bt,t[g+1]=It,p===0){var _t=Z-G,Bt=$-Q;t[v]=_t,t[v+1]=Bt;continue}if(p!==l){var wt=at,me=-ct,ve=Z,ge=-$,be=-c*ht,Ie=-c*ut,_e=-c*Q,Be=-c*G,we=wt+be,Te=me+Ie,Pe=ve+Be,Me=ge-_e,Ot=o+d-p,Ft=o+f-p;t[Ot]=we,t[Ot+1]=Te,t[Ft]=Pe,t[Ft+1]=Me}}}}_singleRealTransform2(t,e,s){const r=this._out,i=this._data,o=i[e],a=i[e+s],u=o+a,c=o-a;r[t]=u,r[t+1]=0,r[t+2]=c,r[t+3]=0}_singleRealTransform4(t,e,s){const r=this._out,i=this._data,o=this._inv?-1:1,a=s*2,u=s*3,c=i[e],h=i[e+s],f=i[e+a],d=i[e+u],l=c+f,p=c-f,m=h+d,I=o*(h-d),g=l+m,v=p,B=-I,T=l-m,M=p,S=I;r[t]=g,r[t+1]=0,r[t+2]=v,r[t+3]=B,r[t+4]=T,r[t+5]=0,r[t+6]=M,r[t+7]=S}}let kt=n=>console.log(n);const Et=(...n)=>kt(...n),Dt=(n,t,e)=>Math.min(Math.max(n,t),e),Pt=n=>n/(1+n),zt=(n,t)=>(n%t+t)%t,Wt=(n,t)=>(1+t)*n/(1+t*Math.abs(n)),L=(n,t)=>Math.tanh(n*(1+t)),qt=(n,t)=>Dt((1+t)*n,-1,1),Mt=(n,t)=>{let e=(1+.5*t)*n;const s=zt(e+1,4);return 1-Math.abs(s-2)},Lt=(n,t)=>Math.sin(Math.PI/2*Mt(n,t)),Yt=(n,t)=>{const e=Pt(Math.log1p(t)),s=(n-e/3*n*n*n)/(1-e/3);return L(s,t)},St=(n,t,e=!1)=>{const s=1+2*t,i=.07*Pt(Math.log1p(t)),o=L(n+i,2*t),a=L(e?i:-n+i,2*t),u=o-a,c=1/Math.cosh(s*i),h=c*c,f=Math.max(1e-8,(e?1:2)*s*h);return L(u/f,t)},Vt={scurve:Wt,soft:L,hard:qt,cubic:Yt,diode:St,asym:(n,t)=>St(n,t,!0),fold:Mt,sinefold:Lt,chebyshev:(n,t)=>{const e=10*Math.log1p(t);let s=1,r=n,i,o=0;for(let a=1;a<64;a++){if(a<2){o+=a==0?s:r;continue}i=2*n*s-r,r=s,s=i,a%2===0&&(o+=Math.min(1.3*e/a,2)*i)}return L(o,e/20)}},J=Object.freeze(Object.keys(Vt)),jt=n=>{let t=n;typeof n=="string"&&(t=J.indexOf(n),t===-1&&(Et(`[superdough] Could not find waveshaping algorithm ${n}.
        Available options are ${J.join(", ")}.
        Defaulting to ${J[0]}.`),t=0));const e=J[t%J.length];return Vt[e]},Y=128,C=Math.PI,R=2*C,W=1/sampleRate,w=(n,t,e)=>Math.min(Math.max(n,t),e),Ht=(n,t,e)=>e*(t-n)+n,b=(n,t)=>n[t]??n[0],j=n=>n-Math.floor(n),H=n=>n|0,K=n=>H(n+.5),Kt=n=>H(n+1),xt=n=>n-H(n),D=n=>{const t=n**2;return n*(27+t)/(27+9*t)},yt=(n,t)=>{if(n<2)return r=>0;const e=t/(n-1),s=t*.5;return r=>r*e-s},U=(n,t)=>n*Math.pow(2,t/12);function Ut(n,t){t=Math.min(t,1-t);const e=1/t;return n<t?(n*=e,2*n-n**2-1):n>1-t?(n=(n-1)*e,n**2+2*n+1):0}const lt={tri(n,t=.5){const e=1-t;return n>=t?1/e-n/e:n/t},sine(n){return Math.sin(R*n)*.5+.5},ramp(n){return n},saw(n){return 1-n},square(n,t=.5){return n>=t?0:1},custom(n,t=[0,1]){const e=t.length-1,s=Math.floor(n*e),r=1/e,i=w(t[s],0,1),a=w(t[s+1],0,1),u=i,c=0,h=r;return(a-u)/(h-c)*(n-r*s)+i},sawblep(n,t){return 2*n-1-Ut(n,t)}},Zt=Object.keys(lt);class $t extends AudioWorkletProcessor{static get parameterDescriptors(){return[{name:"begin",defaultValue:0},{name:"time",defaultValue:0},{name:"end",defaultValue:0},{name:"frequency",defaultValue:.5},{name:"skew",defaultValue:.5},{name:"depth",defaultValue:1},{name:"phaseoffset",defaultValue:0},{name:"shape",defaultValue:0},{name:"curve",defaultValue:1},{name:"dcoffset",defaultValue:0},{name:"min",defaultValue:0},{name:"max",defaultValue:1}]}constructor(){super(),this.phase}incrementPhase(t){this.phase+=t,this.phase>1&&(this.phase=this.phase-1)}process(t,e,s){const r=s.begin[0];if(currentTime>=s.end[0])return!1;if(currentTime<=r)return!0;const i=e[0],o=s.frequency[0],a=s.time[0],u=s.depth[0],c=s.skew[0],h=s.phaseoffset[0],f=s.curve[0],d=s.dcoffset[0],l=s.min[0],p=s.max[0],m=Zt[s.shape[0]],I=i[0].length??0;this.phase==null&&(this.phase=xt(a*o+h));const g=o*W;for(let v=0;v<I;v++){for(let B=0;B<i.length;B++){let T=(lt[m](this.phase,c)+d)*u;T=Math.pow(T,f),i[B][v]=w(T,l,p)}this.incrementPhase(g)}return!0}}registerProcessor("lfo-processor",$t);class Gt extends AudioWorkletProcessor{static get parameterDescriptors(){return[{name:"coarse",defaultValue:1}]}constructor(){super(),this.started=!1}process(t,e,s){const r=t[0],i=e[0],o=r[0]!==void 0;if(this.started&&!o)return!1;this.started=o;let a=s.coarse[0]??0;a=Math.max(1,a);for(let u=0;u<Y;u++)for(let c=0;c<r.length;c++)i[c][u]=u%a===0?r[c][u]:i[c][u-1];return!0}}registerProcessor("coarse-processor",Gt);class Qt extends AudioWorkletProcessor{static get parameterDescriptors(){return[{name:"crush",defaultValue:0}]}constructor(){super(),this.started=!1}process(t,e,s){const r=t[0],i=e[0],o=r[0]!==void 0;if(this.started&&!o)return!1;this.started=o;let a=s.crush[0]??8;a=Math.max(1,a);for(let u=0;u<Y;u++)for(let c=0;c<r.length;c++){const h=Math.pow(2,a-1);i[c][u]=Math.round(r[c][u]*h)/h}return!0}}registerProcessor("crush-processor",Qt);class Jt extends AudioWorkletProcessor{static get parameterDescriptors(){return[{name:"shape",defaultValue:0},{name:"postgain",defaultValue:1}]}constructor(){super(),this.started=!1}process(t,e,s){const r=t[0],i=e[0],o=r[0]!==void 0;if(this.started&&!o)return!1;this.started=o;let a=s.shape[0];a=a<1?a:1-4e-10,a=2*a/(1-a);const u=Math.max(.001,Math.min(1,s.postgain[0]));for(let c=0;c<Y;c++)for(let h=0;h<r.length;h++)i[h][c]=(1+a)*r[h][c]/(1+a*Math.abs(r[h][c]))*u;return!0}}registerProcessor("shape-processor",Jt);class At{s0=0;s1=0;update(t,e,s=0){s=w(s,0,1),e=w(e,0,sampleRate/2-1);const r=w(2*Math.sin(e*C*W),0,1.14),o=1-Math.pow(.5,8*s+1)*r;return this.s0=o*this.s0-r*this.s1+r*t,this.s1=o*this.s1+r*this.s0,this.s1}}class Xt extends AudioWorkletProcessor{static get parameterDescriptors(){return[{name:"value",defaultValue:.5}]}constructor(){super(),this.filters=[new At,new At]}process(t,e,s){const r=t[0],i=e[0],o=r[0]!==void 0;this.started=o;const a=w(s.value[0],0,1);let u="none",c,h=1;a>.51?(u="hipass",h=(a-.5)*2):a<.49&&(u="lopass",h=a*2),c=Math.pow(h*11,4);for(let f=0;f<r.length;f++)for(let d=0;d<Y;d++)u=="none"?i[f][d]=r[f][d]:(this.filters[f].update(r[f][d],c,.1),u==="lopass"?i[f][d]=this.filters[f].s1:u==="hipass"?i[f][d]=r[f][d]-this.filters[f].s1:i[f][d]=r[f][d]);return!0}}registerProcessor("djf-processor",Xt);class te extends AudioWorkletProcessor{static get parameterDescriptors(){return[{name:"frequency",defaultValue:500},{name:"q",defaultValue:1},{name:"drive",defaultValue:.69}]}constructor(){super(),this.started=!1,this.p0=[0,0],this.p1=[0,0],this.p2=[0,0],this.p3=[0,0],this.p32=[0,0],this.p33=[0,0],this.p34=[0,0]}process(t,e,s){const r=t[0],i=e[0],o=r[0]!==void 0;if(this.started&&!o)return!1;this.started=o;const a=s.q[0],u=w(Math.exp(s.drive[0]),.1,2e3);let c=s.frequency[0];c=c*R*W,c=c>1?1:c;const h=Math.min(8,a*.13);let f=1/u*Math.min(1.75,1+h);for(let d=0;d<Y;d++)for(let l=0;l<r.length;l++){const p=this.p3[l]*.360891+this.p32[l]*.41729+this.p33[l]*.177896+this.p34[l]*.0439725;this.p34[l]=this.p33[l],this.p33[l]=this.p32[l],this.p32[l]=this.p3[l],this.p0[l]+=(D(r[l][d]*u-h*p)-D(this.p0[l]))*c,this.p1[l]+=(D(this.p0[l])-D(this.p1[l]))*c,this.p2[l]+=(D(this.p1[l])-D(this.p2[l]))*c,this.p3[l]+=(D(this.p2[l])-D(this.p3[l]))*c,i[l][d]=p*f}return!0}}registerProcessor("ladder-processor",te);class ee extends AudioWorkletProcessor{static get parameterDescriptors(){return[{name:"distort",defaultValue:0},{name:"postgain",defaultValue:1}]}constructor({processorOptions:t}){super(),this.started=!1,this.algorithm=jt(t.algorithm)}process(t,e,s){const r=t[0],i=e[0],o=r[0]!==void 0;if(this.started&&!o)return!1;this.started=o;for(let a=0;a<Y;a++){const u=w(b(s.postgain,a),.001,1),c=Math.expm1(b(s.distort,a));for(let h=0;h<r.length;h++){const f=r[h][a];i[h][a]=u*this.algorithm(f,c)}}return!0}}registerProcessor("distort-processor",ee);class se extends AudioWorkletProcessor{constructor(){super(),this.phase=[]}static get parameterDescriptors(){return[{name:"begin",defaultValue:0,max:Number.POSITIVE_INFINITY,min:0},{name:"end",defaultValue:0,max:Number.POSITIVE_INFINITY,min:0},{name:"frequency",defaultValue:440,min:Number.EPSILON},{name:"panspread",defaultValue:.4,min:0,max:1},{name:"freqspread",defaultValue:.2,min:0},{name:"detune",defaultValue:0,min:0},{name:"voices",defaultValue:5,min:1,automationRate:"k-rate"}]}process(t,e,s){if(currentTime<=s.begin[0])return!0;if(currentTime>=s.end[0])return!1;const r=e[0],i=s.voices[0];for(let o=0;o<r[0].length;o++){const a=b(s.detune,o),u=b(s.freqspread,o),c=b(s.panspread,o)*.5+.5;let h=Math.sqrt(1-c),f=Math.sqrt(c),d=b(s.frequency,o);d=U(d,a/100);const l=yt(i,u);for(let p=0;p<i;p++){const m=U(d,l(p)),I=j(m*W);this.phase[p]=this.phase[p]??Math.random();const g=lt.sawblep(this.phase[p],I);r[0][o]+=g*h,r[1][o]+=g*f;let v=this.phase[p]+I;v>=1&&(v-=1),this.phase[p]=v;const B=h;h=f,f=B}}return!0}}registerProcessor("supersaw-oscillator",se);const re=2048,ft=new Map;function ne(n){if(!ft.has(n)){const t=new Float32Array(n);for(let e=0;e<n;e++)t[e]=.5*(1-Math.cos(R*e/n));ft.set(n,t)}return ft.get(n)}class ie extends Ct{static get parameterDescriptors(){return[{name:"pitchFactor",defaultValue:1}]}constructor(t){t.processorOptions={blockSize:re},super(t),this.timeCursor=0,this.fftSize=this.blockSize,this.invfftSize=1/this.fftSize,this.hannWindow=ne(this.fftSize),this.fft=new Rt(this.fftSize),this.freqComplexBuffer=this.fft.createComplexArray(),this.freqComplexBufferShifted=this.fft.createComplexArray(),this.timeComplexBuffer=this.fft.createComplexArray(),this.magnitudes=new Float32Array(this.fftSize/2+1),this.peakIndexes=new Int32Array(this.magnitudes.length),this.nbPeaks=0}processOLA(t,e,s){let r=s.pitchFactor[s.pitchFactor.length-1];r<0&&(r=r*.25),r=Math.max(0,r+1);for(let i=0;i<this.nbInputs;i++)for(let o=0;o<t[i].length;o++){const a=t[i][o],u=e[i][o];this.applyHannWindow(a),this.fft.realTransform(this.freqComplexBuffer,a),this.computeMagnitudes(),this.findPeaks(),this.shiftPeaks(r),this.fft.completeSpectrum(this.freqComplexBufferShifted),this.fft.inverseTransform(this.timeComplexBuffer,this.freqComplexBufferShifted),this.fft.fromComplexArray(this.timeComplexBuffer,u),this.applyHannWindow(u)}this.timeCursor+=this.hopSize}applyHannWindow(t){for(let e=0;e<this.blockSize;e++)t[e]*=this.hannWindow[e]*1.62}computeMagnitudes(){let t=0,e=0;for(;t<this.magnitudes.length;){const s=this.freqComplexBuffer[e],r=this.freqComplexBuffer[e+1];this.magnitudes[t]=s**2+r**2,t+=1,e+=2}}findPeaks(){this.nbPeaks=0;let t=2;const e=this.magnitudes.length-2;for(;t<e;){const s=this.magnitudes[t];if(this.magnitudes[t-1]>=s||this.magnitudes[t-2]>=s){t++;continue}if(this.magnitudes[t+1]>=s||this.magnitudes[t+2]>=s){t++;continue}this.peakIndexes[this.nbPeaks]=t,this.nbPeaks++,t+=2}}shiftPeaks(t){this.freqComplexBufferShifted.fill(0);for(let e=0;e<this.nbPeaks;e++){const s=this.peakIndexes[e],r=K(s*t);if(r>this.magnitudes.length)break;let i=0,o=this.fftSize;e>0&&(i=s-K((s-this.peakIndexes[e-1])/2)),e<this.nbPeaks-1&&(o=s+Kt((this.peakIndexes[e+1]-s)/2));const a=i-s,u=o-s,c=R*this.invfftSize*(r-s),h=Math.cos(c*this.timeCursor),f=Math.sin(c*this.timeCursor);for(let d=a;d<u;d++){const l=s+d,p=r+d;if(p>=this.magnitudes.length)break;const m=2*l,I=m+1,g=this.freqComplexBuffer[m],v=this.freqComplexBuffer[I],B=g*h-v*f,T=g*f+v*h,M=2*p,S=M+1;this.freqComplexBufferShifted[M]+=B,this.freqComplexBufferShifted[S]+=T}}}}registerProcessor("phase-vocoder-processor",ie);class oe extends AudioWorkletProcessor{constructor(){super(),this.phi=-C,this.Y0=0,this.Y1=0,this.PW=C,this.B=2.3,this.dphif=0,this.envf=0}static get parameterDescriptors(){return[{name:"begin",defaultValue:0,max:Number.POSITIVE_INFINITY,min:0},{name:"end",defaultValue:0,max:Number.POSITIVE_INFINITY,min:0},{name:"frequency",defaultValue:440,min:Number.EPSILON},{name:"detune",defaultValue:0,min:Number.NEGATIVE_INFINITY,max:Number.POSITIVE_INFINITY},{name:"pulsewidth",defaultValue:1,min:0,max:Number.POSITIVE_INFINITY}]}process(t,e,s){if(this.disconnected)return!1;if(currentTime<=s.begin[0])return!0;if(currentTime>=s.end[0])return!1;const r=e[0];let i=1,o;for(let a=0;a<(r[0].length??0);a++){const u=(1-w(b(s.pulsewidth,a),-.99,.99))*C,c=b(s.detune,a),h=U(b(s.frequency,a),c/100);o=h*R*W,this.dphif+=.1*(o-this.dphif),i*=.9998,this.envf+=.1*(i-this.envf),this.B=2.3*(1-1e-4*h),this.B<0&&(this.B=0),this.phi+=this.dphif,this.phi>=C&&(this.phi-=R);let f=Math.cos(this.phi+this.B*this.Y0);this.Y0=.5*(f+this.Y0);let d=Math.cos(this.phi+this.B*this.Y1+u);this.Y1=.5*(d+this.Y1);for(let l=0;l<r.length;l++)r[l][a]=.15*(f-d)*this.envf}return!0}}registerProcessor("pulse-oscillator",oe);const dt={bitC:function(n,t,e){return n&t?e:0},br:function(n,t=8){if(t>32)throw new Error("br() Size cannot be greater than 32");let e=0;for(let s=0;s<t;s++)e|=dt.bitC(n,1<<s,1<<t-(s+1));return e},sinf:function(n){return Math.sin(n*C/128)},cosf:function(n){return Math.cos(n*C/128)},tanf:function(n){return Math.tan(n*C/128)},regG:function(n,t){return t.test(n.toString(2))}};let X,pt;function ae(n){if(X==null){X=Object.getOwnPropertyNames(Math),pt=X.map(s=>Math[s]);const t=Object.getOwnPropertyNames(dt),e=t.map(s=>dt[s]);X.push("int","window",...t),pt.push(Math.floor,globalThis,...e)}return new Function(...X,"t",`return 0,
${n||0};`).bind(globalThis,...pt)}class ce extends AudioWorkletProcessor{constructor(){super(),this.port.onmessage=t=>{let{codeText:e}=t.data;const{byteBeatStartTime:s}=t.data;s!=null&&(this.t=0,this.initialOffset=Math.floor(s)),e=e.trim().replace(/^eval\(unescape\(escape(?:`|\('|\("|\(`)(.*?)(?:`|'\)|"\)|`\)).replace\(\/u\(\.\.\)\/g,["'`]\$1%["'`]\)\)\)$/,(r,i)=>unescape(escape(i).replace(/u(..)/g,"$1%"))),this.func=ae(e)},this.initialOffset=0,this.t=null,this.func=null}static get parameterDescriptors(){return[{name:"begin",defaultValue:0,max:Number.POSITIVE_INFINITY,min:0},{name:"frequency",defaultValue:440,min:Number.EPSILON},{name:"detune",defaultValue:0,min:Number.NEGATIVE_INFINITY,max:Number.POSITIVE_INFINITY},{name:"end",defaultValue:0,max:Number.POSITIVE_INFINITY,min:0}]}process(t,e,s){if(this.disconnected)return!1;if(currentTime<=s.begin[0])return!0;if(currentTime>=s.end[0])return!1;this.t==null&&(this.t=s.begin[0]*sampleRate);const r=e[0],i=256*W;for(let o=0;o<r[0].length;o++){const a=b(s.detune,o),u=U(b(s.frequency,o),a/100),c=i*u*this.t+this.initialOffset,f=(this.func(c)&255)/127.5-1,d=w(f*.2,-.4,.4);for(let l=0;l<r.length;l++)r[l][o]=d;this.t++}return!0}}registerProcessor("byte-beat-processor",ce);class ue extends AudioWorkletProcessor{static get parameterDescriptors(){return[{name:"begin",defaultValue:0},{name:"end",defaultValue:0},{name:"attack",defaultValue:.005,minValue:0},{name:"decay",defaultValue:.14,minValue:0},{name:"sustain",defaultValue:0,minValue:0,maxValue:1},{name:"release",defaultValue:.1,minValue:0},{name:"attackCurve",defaultValue:0,minValue:-1,maxValue:1},{name:"decayCurve",defaultValue:0,minValue:-1,maxValue:1},{name:"releaseCurve",defaultValue:0,minValue:-1,maxValue:1},{name:"peak",defaultValue:1},{name:"retrigger",defaultValue:1,minValue:0,maxValue:1}]}constructor(){super(),this.val=0,this.segIdx=0,this.state=0,this.beginTime=0,this.endTime=0,this.attackStart=0}_warp(t,e,s=8){if(t===0||t===1)return t;if(e>0){const r=1+s*e;return 1-Math.pow(1-t,r)}else{const r=1-s*e;return Math.pow(t,r)}}_advance(t,e,s,r){if(s===0||t===e)this.val=e;else{const i=Math.min(1,(currentTime-this.beginTime)/s),o=this._warp(i,r);this.val=t+(e-t)*o}}process(t,e,s){const r=e[0][0];if(!r)return!0;const i=b(s.begin,0),o=b(s.retrigger,0)>=.5;i!==this.beginTime&&(this.state===0||o)&&(this.beginTime=i,this.state=1,this.endTime=b(s.end,0),this.attackStart=this.val);const a=this.endTime-this.beginTime;for(let u=0;u<r.length;u++){const c=b(s.attack,u),h=b(s.decay,u),f=b(s.sustain,u),d=b(s.release,u),l=b(s.attackCurve,u),p=b(s.decayCurve,u),m=b(s.releaseCurve,u),I=b(s.peak,u),g=[{time:Number.POSITIVE_INFINITY,start:0,target:0},{time:c,start:this.attackStart,target:1,curve:l},{time:c+h,start:1,target:f,curve:p},{time:a,start:f,target:f},{time:a+d,start:f,target:0,curve:m}];let{time:v,start:B,target:T,curve:M}=g[this.state];for(this._advance(B,T,v,M);currentTime-this.beginTime>=v;)this.state=(this.state+1)%g.length,v=g[this.state].time;r[u]=this.val*I}return!0}}registerProcessor("envelope-processor",ue);const _=Object.freeze({NONE:0,ASYM:1,MIRROR:2,BENDP:3,BENDM:4,BENDMP:5,SYNC:6,QUANT:7,FOLD:8,PWM:9,ORBIT:10,SPIN:11,CHAOS:12,PRIMES:13,BINARY:14,BROWNIAN:15,RECIPROCAL:16,WORMHOLE:17,LOGISTIC:18,SIGMOID:19,FRACTAL:20,FLIP:21});function he(n){return n=n+2127912214+(n<<12),n=n^3345072700^n>>>19,n=n+374761393+(n<<5),n=n+3550635116^n<<9,n=n+4251993797+(n<<3),n=n^3042594569^n>>>16,n>>>0}const Nt=n=>(he(n)>>>8)/16777216;function le(n,t){let e=0;for(let s=0;s<t;s++)e=e<<1|n&1,n>>>=1;return e}function fe(n){const t=Math.floor(n),e=n-t,s=Nt(t),r=Nt(t+1);return s+(r-s)*e}function de(n,t=4){let e=.5,s=0,r=0,i=1;for(let o=0;o<t;o++)s+=e*fe(n*i),r+=e,e*=.5,i*=2;return s/r*2-1}const mt={};class pe extends AudioWorkletProcessor{static get parameterDescriptors(){return[{name:"begin",defaultValue:0,min:0,max:Number.POSITIVE_INFINITY},{name:"end",defaultValue:0,min:0,max:Number.POSITIVE_INFINITY},{name:"frequency",defaultValue:440,min:Number.EPSILON},{name:"detune",defaultValue:0},{name:"freqspread",defaultValue:.18,min:0},{name:"position",defaultValue:0,min:0,max:1},{name:"warp",defaultValue:0,min:0,max:1},{name:"warpMode",defaultValue:0},{name:"voices",defaultValue:1,min:1,automationRate:"k-rate"},{name:"panspread",defaultValue:.7,min:0,max:1},{name:"phaserand",defaultValue:0,min:0,max:1}]}constructor(t){super(t),this.frameLen=0,this.numFrames=0,this.phase=[],this.port.onmessage=e=>{const{type:s,payload:r}=e.data||{};if(s==="table"){const i=r.key;if(this.frameLen=r.frameLen,!mt[i]){const o=[r.frames];let a=o[0];for(let u=1;u<1;u++){const c=a.length>>1,h=a.map(f=>{const d=new Float32Array(c);for(let l=0;l<c;l++)d[l]=(f[2*l]+f[2*l+1])/2;return d});if(o.push(h),a=h,c<=32)break}mt[i]=o}this.tables=mt[i],this.numFrames=this.tables[0].length}}}_mirror(t){return 1-Math.abs(2*t-1)}_toBits(t,e=2,s=12){const r=s+(e-s)*t;return{b:r,n:K(Math.pow(2,r))}}_warpPhase(t,e,s){switch(s){case _.NONE:return t;case _.ASYM:{const r=.01+.99*e;return t<r?.5*t/r:.5+.5*(t-r)/(1-r)}case _.MIRROR:return this._mirror(this._warpPhase(t,e,_.ASYM));case _.BENDP:return Math.pow(t,1+3*e);case _.BENDM:return Math.pow(t,1/(1+3*e));case _.BENDMP:return e<.5?this._warpPhase(t,1-2*e,3):this._warpPhase(t,2*e-1,2);case _.SYNC:{const r=Math.pow(16,e**2);return t*r%1}case _.QUANT:{const{n:r}=this._toBits(e);return H(t*r)/r}case _.FOLD:{const i=1+Math.max(1,K(7*e));return Math.abs(xt(i*t)-.5)*2}case _.PWM:{const r=w(.5+.49*(2*e-1),0,1);return t<r?t/r*.5:.5+(t-r)/(1-r)*.5}case _.ORBIT:{const r=.5*e;return j(t+r*Math.sin(R*3*t))}case _.SPIN:{const r=.5*e,{n:i}=this._toBits(e,1,6);return j(t+r*Math.sin(R*i*t))}case _.CHAOS:{const i=(3.7+.3*e)*t*(1-t);return w((1-e)*t+e*i,0,1)}case _.PRIMES:{const r=o=>{if(o<2)return!1;if(o%2===0)return o===2;for(let a=3;a**2<=o;a+=2)if(o%a===0)return!1;return!0};let{n:i}=this._toBits(e,3);for(;!r(i);)i++;return H(t*i)/i}case _.BINARY:{let{b:r}=this._toBits(e,3);r=K(r);const i=1<<r,o=H(t*i);return le(o,r)/i}case _.BROWNIAN:{const r=.25*e*de(64*t,4);return j(t+r)}case _.RECIPROCAL:{const r=2+4*e,i=t*r,o=t+(1-t)*r,a=o>1e-12?i/o:0;return w(a,0,1)}case _.WORMHOLE:{const r=w(.8*e,0,1),i=.5*(1-r),o=.5*(1+r);return t<i?t/i*.5:t>o?.5*(1+(t-o)/(1-o)):.5}case _.LOGISTIC:{let r=t;const i=3.6+.4*e,o=1+K(2*e);for(let a=0;a<o;a++)r=i*r*(1-r);return w(r,0,1)}case _.SIGMOID:{const r=1+10*e,i=t-.5,o=1/(1+Math.exp(-r*i)),a=1/(1+Math.exp(.5*r)),u=1/(1+Math.exp(-.5*r));return(o-a)/(u-a)}case _.FRACTAL:{const r=.5*Math.sin(R*t)*e;return j(t+r)}case _.FLIP:return t;default:return t}}_sampleFrame(t,e){const s=t.length,r=e*s;let i=r|0;i>=s&&(i=0);const o=r-i,a=t[i];let u=i+1;u>=s&&(u=0);const c=t[u];return a+(c-a)*o}_chooseMip(t){const e=w(t,1e-6,64);let s=0;for(;s+1<(this.tables?.length||1)&&e<this.tables[s][0].length/8;)s++;return s}process(t,e,s){if(currentTime>=s.end[0])return!1;if(currentTime<=s.begin[0])return!0;const r=e[0][0],i=e[0][1]||e[0][0];if(!this.tables)return r.fill(0),i!==r&&i.set(r),!0;const o=s.voices[0];for(let a=0;a<r.length;a++){const u=b(s.detune,a),c=b(s.freqspread,a),f=w(b(s.position,a),0,1)*(this.numFrames-1),d=f|0,l=f-d,p=w(b(s.warp,a),0,1),m=b(s.warpMode,a),I=w(b(s.phaserand,a),0,1),g=o>1?w(b(s.panspread,a),0,1):0,v=Math.sqrt(.5-.5*g),B=Math.sqrt(.5+.5*g);let T=b(s.frequency,a);T=U(T,u/100);const M=1/Math.sqrt(o),S=yt(o,c);for(let P=0;P<o;P++){const V=(P&1)==1;let x=v,y=B;V&&(x=B,y=v);const A=U(T,S(P))*W,k=this._chooseMip(A),N=this.tables[k];this.phase[P]=this.phase[P]??Math.random()*I;const O=this._warpPhase(this.phase[P],p,m),E=this._sampleFrame(N[d],O),q=this._sampleFrame(N[Math.min(this.numFrames-1,d+1)],O);let F=Ht(E,q,l);m===_.FLIP&&this.phase[P]<p&&(F=-F),r[a]+=F*x*M,i[a]+=F*y*M,this.phase[P]=j(this.phase[P]+A)}}return!0}}registerProcessor("wavetable-oscillator-processor",pe)})();
